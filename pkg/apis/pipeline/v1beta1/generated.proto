/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package github.com.tektoncd.pipeline.pkg.apis.pipeline.v1beta1;

import "k8s.io/apimachinery/pkg/api/resource/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";
import "k8s.io/apimachinery/pkg/util/intstr/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "v1beta1";

message AWSElasticBlockStoreVolumeSource {
  // Unique ID of the persistent disk resource in AWS (Amazon EBS volume).
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  optional string volumeID = 1;

  // Filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  // +optional
  optional string fsType = 2;

  // The partition in the volume that you want to mount.
  // If omitted, the default is to mount by volume name.
  // Examples: For volume /dev/sda1, you specify the partition as "1".
  // Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
  // +optional
  optional int32 partition = 3;

  // Specify "true" to force and set the ReadOnly property in VolumeMounts to "true".
  // If omitted, the default is "false".
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  // +optional
  optional bool readOnly = 4;
}

message Affinity {
  // Describes node affinity scheduling rules for the pod.
  // +optional
  optional NodeAffinity nodeAffinity = 1;

  // Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
  // +optional
  optional PodAffinity podAffinity = 2;

  // Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
  // +optional
  optional PodAntiAffinity podAntiAffinity = 3;
}

message AzureDiskVolumeSource {
  // The Name of the data disk in the blob storage
  optional string diskName = 1;

  // The URI the data disk in the blob storage
  optional string diskURI = 2;

  // Host Caching mode: None, Read Only, Read Write.
  // +optional
  optional string cachingMode = 3;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // +optional
  optional string fsType = 4;

  // Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // +optional
  optional bool readOnly = 5;

  // Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
  optional string kind = 6;
}

message AzureFileVolumeSource {
  // the name of secret that contains Azure Storage Account Name and Key
  optional string secretName = 1;

  // Share Name
  optional string shareName = 2;

  // Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // +optional
  optional bool readOnly = 3;
}

message CSIVolumeSource {
  // Driver is the name of the CSI driver that handles this volume.
  // Consult with your admin for the correct name as registered in the cluster.
  optional string driver = 1;

  // Specifies a read-only configuration for the volume.
  // Defaults to false (read/write).
  // +optional
  optional bool readOnly = 2;

  // Filesystem type to mount. Ex. "ext4", "xfs", "ntfs".
  // If not provided, the empty value is passed to the associated CSI driver
  // which will determine the default filesystem to apply.
  // +optional
  optional string fsType = 3;

  // VolumeAttributes stores driver-specific properties that are passed to the CSI
  // driver. Consult your driver's documentation for supported values.
  // +optional
  map<string, string> volumeAttributes = 4;

  // NodePublishSecretRef is a reference to the secret object containing
  // sensitive information to pass to the CSI driver to complete the CSI
  // NodePublishVolume and NodeUnpublishVolume calls.
  // This field is optional, and  may be empty if no secret is required. If the
  // secret object contains more than one secret, all secret references are passed.
  // +optional
  optional LocalObjectReference nodePublishSecretRef = 5;
}

message Capabilities {
  // Added capabilities
  // +optional
  repeated string add = 1;

  // Removed capabilities
  // +optional
  repeated string drop = 2;
}

message CephFSVolumeSource {
  // Required: Monitors is a collection of Ceph monitors
  // More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  repeated string monitors = 1;

  // Optional: Used as the mounted root, rather than the full Ceph tree, default is /
  // +optional
  optional string path = 2;

  // Optional: User is the rados user name, default is admin
  // More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  // +optional
  optional string user = 3;

  // Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
  // More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  // +optional
  optional string secretFile = 4;

  // Optional: SecretRef is reference to the authentication secret for User, default is empty.
  // More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  // +optional
  optional LocalObjectReference secretRef = 5;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  // +optional
  optional bool readOnly = 6;
}

message CinderVolumeSource {
  // volume id used to identify the volume in cinder.
  // More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  optional string volumeID = 1;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  // +optional
  optional string fsType = 2;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  // +optional
  optional bool readOnly = 3;

  // Optional: points to a secret object containing parameters used to connect
  // to OpenStack.
  // +optional
  optional LocalObjectReference secretRef = 4;
}

message ConfigMapEnvSource {
  // The ConfigMap to select from.
  optional LocalObjectReference localObjectReference = 1;

  // Specify whether the ConfigMap must be defined
  // +optional
  optional bool optional = 2;
}

message ConfigMapKeySelector {
  // The ConfigMap to select from.
  optional LocalObjectReference localObjectReference = 1;

  // The key to select.
  optional string key = 2;

  // Specify whether the ConfigMap or its key must be defined
  // +optional
  optional bool optional = 3;
}

message ConfigMapProjection {
  optional LocalObjectReference localObjectReference = 1;

  // If unspecified, each key-value pair in the Data field of the referenced
  // ConfigMap will be projected into the volume as a file whose name is the
  // key and content is the value. If specified, the listed keys will be
  // projected into the specified paths, and unlisted keys will not be
  // present. If a key is specified which is not present in the ConfigMap,
  // the volume setup will error unless it is marked optional. Paths must be
  // relative and may not contain the '..' path or start with '..'.
  // +optional
  repeated KeyToPath items = 2;

  // Specify whether the ConfigMap or its keys must be defined
  // +optional
  optional bool optional = 4;
}

message ConfigMapVolumeSource {
  optional LocalObjectReference localObjectReference = 1;

  // If unspecified, each key-value pair in the Data field of the referenced
  // ConfigMap will be projected into the volume as a file whose name is the
  // key and content is the value. If specified, the listed keys will be
  // projected into the specified paths, and unlisted keys will not be
  // present. If a key is specified which is not present in the ConfigMap,
  // the volume setup will error unless it is marked optional. Paths must be
  // relative and may not contain the '..' path or start with '..'.
  // +optional
  repeated KeyToPath items = 2;

  // Optional: mode bits to use on created files by default. Must be a
  // value between 0 and 0777. Defaults to 0644.
  // Directories within the path are not affected by this setting.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  optional int32 defaultMode = 3;

  // Specify whether the ConfigMap or its keys must be defined
  // +optional
  optional bool optional = 4;
}

message Container {
  // Name of the container specified as a DNS_LABEL.
  // Each container in a pod must have a unique name (DNS_LABEL).
  // Cannot be updated.
  optional string name = 1;

  // Docker image name.
  // More info: https://kubernetes.io/docs/concepts/containers/images
  // This field is optional to allow higher level config management to default or override
  // container images in workload controllers like Deployments and StatefulSets.
  // +optional
  optional string image = 2;

  // Entrypoint array. Not executed within a shell.
  // The docker image's ENTRYPOINT is used if this is not provided.
  // Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
  // cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
  // can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
  // regardless of whether the variable exists or not.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  // +optional
  repeated string command = 3;

  // Arguments to the entrypoint.
  // The docker image's CMD is used if this is not provided.
  // Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
  // cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
  // can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
  // regardless of whether the variable exists or not.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  // +optional
  repeated string args = 4;

  // Container's working directory.
  // If not specified, the container runtime's default will be used, which
  // might be configured in the container image.
  // Cannot be updated.
  // +optional
  optional string workingDir = 5;

  // List of ports to expose from the container. Exposing a port here gives
  // the system additional information about the network connections a
  // container uses, but is primarily informational. Not specifying a port here
  // DOES NOT prevent that port from being exposed. Any port which is
  // listening on the default "0.0.0.0" address inside a container will be
  // accessible from the network.
  // Cannot be updated.
  // +optional
  // +patchMergeKey=containerPort
  // +patchStrategy=merge
  // +listType=map
  // +listMapKey=containerPort
  // +listMapKey=protocol
  repeated ContainerPort ports = 6;

  // List of sources to populate environment variables in the container.
  // The keys defined within a source must be a C_IDENTIFIER. All invalid keys
  // will be reported as an event when the container is starting. When a key exists in multiple
  // sources, the value associated with the last source will take precedence.
  // Values defined by an Env with a duplicate key will take precedence.
  // Cannot be updated.
  // +optional
  repeated EnvFromSource envFrom = 19;

  // List of environment variables to set in the container.
  // Cannot be updated.
  // +optional
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated EnvVar env = 7;

  // Compute Resources required by this container.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
  // +optional
  optional ResourceRequirements resources = 8;

  // Pod volumes to mount into the container's filesystem.
  // Cannot be updated.
  // +optional
  // +patchMergeKey=mountPath
  // +patchStrategy=merge
  repeated VolumeMount volumeMounts = 9;

  // volumeDevices is the list of block devices to be used by the container.
  // This is a beta feature.
  // +patchMergeKey=devicePath
  // +patchStrategy=merge
  // +optional
  repeated VolumeDevice volumeDevices = 21;

  // Periodic probe of container liveness.
  // Container will be restarted if the probe fails.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  // +optional
  optional Probe livenessProbe = 10;

  // Periodic probe of container service readiness.
  // Container will be removed from service endpoints if the probe fails.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  // +optional
  optional Probe readinessProbe = 11;

  // StartupProbe indicates that the Pod has successfully initialized.
  // If specified, no other probes are executed until this completes successfully.
  // If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
  // This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
  // when it might take a long time to load data or warm a cache, than during steady-state operation.
  // This cannot be updated.
  // This is an alpha feature enabled by the StartupProbe feature flag.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  // +optional
  optional Probe startupProbe = 22;

  // Actions that the management system should take in response to container lifecycle events.
  // Cannot be updated.
  // +optional
  optional Lifecycle lifecycle = 12;

  // Optional: Path at which the file to which the container's termination message
  // will be written is mounted into the container's filesystem.
  // Message written is intended to be brief final status, such as an assertion failure message.
  // Will be truncated by the node if greater than 4096 bytes. The total message length across
  // all containers will be limited to 12kb.
  // Defaults to /dev/termination-log.
  // Cannot be updated.
  // +optional
  optional string terminationMessagePath = 13;

  // Indicate how the termination message should be populated. File will use the contents of
  // terminationMessagePath to populate the container status message on both success and failure.
  // FallbackToLogsOnError will use the last chunk of container log output if the termination
  // message file is empty and the container exited with an error.
  // The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
  // Defaults to File.
  // Cannot be updated.
  // +optional
  optional string terminationMessagePolicy = 20;

  // Image pull policy.
  // One of Always, Never, IfNotPresent.
  // Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
  // +optional
  optional string imagePullPolicy = 14;

  // Security options the pod should run with.
  // More info: https://kubernetes.io/docs/concepts/policy/security-context/
  // More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  // +optional
  optional SecurityContext securityContext = 15;

  // Whether this container should allocate a buffer for stdin in the container runtime. If this
  // is not set, reads from stdin in the container will always result in EOF.
  // Default is false.
  // +optional
  optional bool stdin = 16;

  // Whether the container runtime should close the stdin channel after it has been opened by
  // a single attach. When stdin is true the stdin stream will remain open across multiple attach
  // sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
  // first client attaches to stdin, and then remains open and accepts data until the client disconnects,
  // at which time stdin is closed and remains closed until the container is restarted. If this
  // flag is false, a container processes that reads from stdin will never receive an EOF.
  // Default is false
  // +optional
  optional bool stdinOnce = 17;

  // Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
  // Default is false.
  // +optional
  optional bool tty = 18;
}

message ContainerPort {
  // If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
  // named port in a pod must have a unique name. Name for the port that can be
  // referred to by services.
  // +optional
  optional string name = 1;

  // Number of port to expose on the host.
  // If specified, this must be a valid port number, 0 < x < 65536.
  // If HostNetwork is specified, this must match ContainerPort.
  // Most containers do not need this.
  // +optional
  optional int32 hostPort = 2;

  // Number of port to expose on the pod's IP address.
  // This must be a valid port number, 0 < x < 65536.
  optional int32 containerPort = 3;

  // Protocol for port. Must be UDP, TCP, or SCTP.
  // Defaults to "TCP".
  // +optional
  optional string protocol = 4;

  // What host IP to bind the external port to.
  // +optional
  optional string hostIP = 5;
}

message ContainerState {
  // Details about a waiting container
  // +optional
  optional ContainerStateWaiting waiting = 1;

  // Details about a running container
  // +optional
  optional ContainerStateRunning running = 2;

  // Details about a terminated container
  // +optional
  optional ContainerStateTerminated terminated = 3;
}

message ContainerStateRunning {
  // Time at which the container was last (re-)started
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 1;
}

message ContainerStateTerminated {
  // Exit status from the last termination of the container
  optional int32 exitCode = 1;

  // Signal from the last termination of the container
  // +optional
  optional int32 signal = 2;

  // (brief) reason from the last termination of the container
  // +optional
  optional string reason = 3;

  // Message regarding the last termination of the container
  // +optional
  optional string message = 4;

  // Time at which previous execution of the container started
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 5;

  // Time at which the container last terminated
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time finishedAt = 6;

  // Container's ID in the format 'docker://<container_id>'
  // +optional
  optional string containerID = 7;
}

message ContainerStateWaiting {
  // (brief) reason the container is not yet running.
  // +optional
  optional string reason = 1;

  // Message regarding why the container is not yet running.
  // +optional
  optional string message = 2;
}

message DownwardAPIProjection {
  // Items is a list of DownwardAPIVolume file
  // +optional
  repeated DownwardAPIVolumeFile items = 1;
}

message DownwardAPIVolumeFile {
  // Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
  optional string path = 1;

  // Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
  // +optional
  optional ObjectFieldSelector fieldRef = 2;

  // Selects a resource of the container: only resources limits and requests
  // (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
  // +optional
  optional ResourceFieldSelector resourceFieldRef = 3;

  // Optional: mode bits to use on this file, must be a value between 0
  // and 0777. If not specified, the volume defaultMode will be used.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  optional int32 mode = 4;
}

message DownwardAPIVolumeSource {
  // Items is a list of downward API volume file
  // +optional
  repeated DownwardAPIVolumeFile items = 1;

  // Optional: mode bits to use on created files by default. Must be a
  // value between 0 and 0777. Defaults to 0644.
  // Directories within the path are not affected by this setting.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  optional int32 defaultMode = 2;
}

message EmptyDirVolumeSource {
  // What type of storage medium should back this directory.
  // The default is "" which means to use the node's default medium.
  // Must be an empty string (default) or Memory.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
  // +optional
  optional string medium = 1;

  // Total amount of local storage required for this EmptyDir volume.
  // The size limit is also applicable for memory medium.
  // The maximum usage on memory medium EmptyDir would be the minimum value between
  // the SizeLimit specified here and the sum of memory limits of all containers in a pod.
  // The default is nil which means that the limit is undefined.
  // More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
  // +optional
  optional k8s.io.apimachinery.pkg.api.resource.Quantity sizeLimit = 2;
}

message EnvFromSource {
  // An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
  // +optional
  optional string prefix = 1;

  // The ConfigMap to select from
  // +optional
  optional ConfigMapEnvSource configMapRef = 2;

  // The Secret to select from
  // +optional
  optional SecretEnvSource secretRef = 3;
}

message EnvVar {
  // Name of the environment variable. Must be a C_IDENTIFIER.
  optional string name = 1;

  // Variable references $(VAR_NAME) are expanded
  // using the previous defined environment variables in the container and
  // any service environment variables. If a variable cannot be resolved,
  // the reference in the input string will be unchanged. The $(VAR_NAME)
  // syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped
  // references will never be expanded, regardless of whether the variable
  // exists or not.
  // Defaults to "".
  // +optional
  optional string value = 2;

  // Source for the environment variable's value. Cannot be used if value is not empty.
  // +optional
  optional EnvVarSource valueFrom = 3;
}

message EnvVarSource {
  // Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations,
  // spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
  // +optional
  optional ObjectFieldSelector fieldRef = 1;

  // Selects a resource of the container: only resources limits and requests
  // (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  // +optional
  optional ResourceFieldSelector resourceFieldRef = 2;

  // Selects a key of a ConfigMap.
  // +optional
  optional ConfigMapKeySelector configMapKeyRef = 3;

  // Selects a key of a secret in the pod's namespace
  // +optional
  optional SecretKeySelector secretKeyRef = 4;
}

message ExecAction {
  // Command is the command line to execute inside the container, the working directory for the
  // command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
  // not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
  // a shell, you need to explicitly call out to that shell.
  // Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
  // +optional
  repeated string command = 1;
}

message FCVolumeSource {
  // Optional: FC target worldwide names (WWNs)
  // +optional
  repeated string targetWWNs = 1;

  // Optional: FC target lun number
  // +optional
  optional int32 lun = 2;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  // +optional
  optional string fsType = 3;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // +optional
  optional bool readOnly = 4;

  // Optional: FC volume world wide identifiers (wwids)
  // Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
  // +optional
  repeated string wwids = 5;
}

message FlexVolumeSource {
  // Driver is the name of the driver to use for this volume.
  optional string driver = 1;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
  // +optional
  optional string fsType = 2;

  // Optional: SecretRef is reference to the secret object containing
  // sensitive information to pass to the plugin scripts. This may be
  // empty if no secret object is specified. If the secret object
  // contains more than one secret, all secrets are passed to the plugin
  // scripts.
  // +optional
  optional LocalObjectReference secretRef = 3;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // +optional
  optional bool readOnly = 4;

  // Optional: Extra command options if any.
  // +optional
  map<string, string> options = 5;
}

message FlockerVolumeSource {
  // Name of the dataset stored as metadata -> name on the dataset for Flocker
  // should be considered as deprecated
  // +optional
  optional string datasetName = 1;

  // UUID of the dataset. This is unique identifier of a Flocker dataset
  // +optional
  optional string datasetUUID = 2;
}

message GCEPersistentDiskVolumeSource {
  // Unique name of the PD resource in GCE. Used to identify the disk in GCE.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  optional string pdName = 1;

  // Filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  // +optional
  optional string fsType = 2;

  // The partition in the volume that you want to mount.
  // If omitted, the default is to mount by volume name.
  // Examples: For volume /dev/sda1, you specify the partition as "1".
  // Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  // +optional
  optional int32 partition = 3;

  // ReadOnly here will force the ReadOnly setting in VolumeMounts.
  // Defaults to false.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  // +optional
  optional bool readOnly = 4;
}

message GitRepoVolumeSource {
  // Repository URL
  optional string repository = 1;

  // Commit hash for the specified revision.
  // +optional
  optional string revision = 2;

  // Target directory name.
  // Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
  // git repository.  Otherwise, if specified, the volume will contain the git repository in
  // the subdirectory with the given name.
  // +optional
  optional string directory = 3;
}

message GlusterfsVolumeSource {
  // EndpointsName is the endpoint name that details Glusterfs topology.
  // More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  optional string endpoints = 1;

  // Path is the Glusterfs volume path.
  // More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  optional string path = 2;

  // ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions.
  // Defaults to false.
  // More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  // +optional
  optional bool readOnly = 3;
}

message HTTPGetAction {
  // Path to access on the HTTP server.
  // +optional
  optional string path = 1;

  // Name or number of the port to access on the container.
  // Number must be in the range 1 to 65535.
  // Name must be an IANA_SVC_NAME.
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;

  // Host name to connect to, defaults to the pod IP. You probably want to set
  // "Host" in httpHeaders instead.
  // +optional
  optional string host = 3;

  // Scheme to use for connecting to the host.
  // Defaults to HTTP.
  // +optional
  optional string scheme = 4;

  // Custom headers to set in the request. HTTP allows repeated headers.
  // +optional
  repeated HTTPHeader httpHeaders = 5;
}

message HTTPHeader {
  // The header field name
  optional string name = 1;

  // The header field value
  optional string value = 2;
}

message Handler {
  // One and only one of the following should be specified.
  // Exec specifies the action to take.
  // +optional
  optional ExecAction exec = 1;

  // HTTPGet specifies the http request to perform.
  // +optional
  optional HTTPGetAction httpGet = 2;

  // TCPSocket specifies an action involving a TCP port.
  // TCP hooks not yet supported
  // TODO: implement a realistic TCP lifecycle hook
  // +optional
  optional TCPSocketAction tcpSocket = 3;
}

message HostPathVolumeSource {
  // Path of the directory on the host.
  // If the path is a symlink, it will follow the link to the real path.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
  optional string path = 1;

  // Type for HostPath Volume
  // Defaults to ""
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
  // +optional
  optional string type = 2;
}

message ISCSIVolumeSource {
  // iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
  // is other than default (typically TCP ports 860 and 3260).
  optional string targetPortal = 1;

  // Target iSCSI Qualified Name.
  optional string iqn = 2;

  // iSCSI Target Lun number.
  optional int32 lun = 3;

  // iSCSI Interface Name that uses an iSCSI transport.
  // Defaults to 'default' (tcp).
  // +optional
  optional string iscsiInterface = 4;

  // Filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  // +optional
  optional string fsType = 5;

  // ReadOnly here will force the ReadOnly setting in VolumeMounts.
  // Defaults to false.
  // +optional
  optional bool readOnly = 6;

  // iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
  // is other than default (typically TCP ports 860 and 3260).
  // +optional
  repeated string portals = 7;

  // whether support iSCSI Discovery CHAP authentication
  // +optional
  optional bool chapAuthDiscovery = 8;

  // whether support iSCSI Session CHAP authentication
  // +optional
  optional bool chapAuthSession = 11;

  // CHAP Secret for iSCSI target and initiator authentication
  // +optional
  optional LocalObjectReference secretRef = 10;

  // Custom iSCSI Initiator Name.
  // If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
  // <target portal>:<volume name> will be created for the connection.
  // +optional
  optional string initiatorName = 12;
}

message KeyToPath {
  // The key to project.
  optional string key = 1;

  // The relative path of the file to map the key to.
  // May not be an absolute path.
  // May not contain the path element '..'.
  // May not start with the string '..'.
  optional string path = 2;

  // Optional: mode bits to use on this file, must be a value between 0
  // and 0777. If not specified, the volume defaultMode will be used.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  optional int32 mode = 3;
}

message Lifecycle {
  // PostStart is called immediately after a container is created. If the handler fails,
  // the container is terminated and restarted according to its restart policy.
  // Other management of the container blocks until the hook completes.
  // More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
  // +optional
  optional Handler postStart = 1;

  // PreStop is called immediately before a container is terminated due to an
  // API request or management event such as liveness/startup probe failure,
  // preemption, resource contention, etc. The handler is not called if the
  // container crashes or exits. The reason for termination is passed to the
  // handler. The Pod's termination grace period countdown begins before the
  // PreStop hooked is executed. Regardless of the outcome of the handler, the
  // container will eventually terminate within the Pod's termination grace
  // period. Other management of the container blocks until the hook completes
  // or until the termination grace period is reached.
  // More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
  // +optional
  optional Handler preStop = 2;
}

message LocalObjectReference {
  // Name of the referent.
  // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  // TODO: Add other useful fields. apiVersion, kind, uid?
  // +optional
  optional string name = 1;
}

message NFSVolumeSource {
  // Server is the hostname or IP address of the NFS server.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  optional string server = 1;

  // Path that is exported by the NFS server.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  optional string path = 2;

  // ReadOnly here will force
  // the NFS export to be mounted with read-only permissions.
  // Defaults to false.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  // +optional
  optional bool readOnly = 3;
}

message NodeAffinity {
  // If the affinity requirements specified by this field are not met at
  // scheduling time, the pod will not be scheduled onto the node.
  // If the affinity requirements specified by this field cease to be met
  // at some point during pod execution (e.g. due to an update), the system
  // may or may not try to eventually evict the pod from its node.
  // +optional
  optional NodeSelector requiredDuringSchedulingIgnoredDuringExecution = 1;

  // The scheduler will prefer to schedule pods to nodes that satisfy
  // the affinity expressions specified by this field, but it may choose
  // a node that violates one or more of the expressions. The node that is
  // most preferred is the one with the greatest sum of weights, i.e.
  // for each node that meets all of the scheduling requirements (resource
  // request, requiredDuringScheduling affinity expressions, etc.),
  // compute a sum by iterating through the elements of this field and adding
  // "weight" to the sum if the node matches the corresponding matchExpressions; the
  // node(s) with the highest sum are the most preferred.
  // +optional
  repeated PreferredSchedulingTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
}

message NodeSelector {
  // Required. A list of node selector terms. The terms are ORed.
  repeated NodeSelectorTerm nodeSelectorTerms = 1;
}

message NodeSelectorRequirement {
  // The label key that the selector applies to.
  optional string key = 1;

  // Represents a key's relationship to a set of values.
  // Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
  optional string operator = 2;

  // An array of string values. If the operator is In or NotIn,
  // the values array must be non-empty. If the operator is Exists or DoesNotExist,
  // the values array must be empty. If the operator is Gt or Lt, the values
  // array must have a single element, which will be interpreted as an integer.
  // This array is replaced during a strategic merge patch.
  // +optional
  repeated string values = 3;
}

message NodeSelectorTerm {
  // A list of node selector requirements by node's labels.
  // +optional
  repeated NodeSelectorRequirement matchExpressions = 1;

  // A list of node selector requirements by node's fields.
  // +optional
  repeated NodeSelectorRequirement matchFields = 2;
}

message ObjectFieldSelector {
  // Version of the schema the FieldPath is written in terms of, defaults to "v1".
  // +optional
  optional string apiVersion = 1;

  // Path of the field to select in the specified API version.
  optional string fieldPath = 2;
}

message PersistentVolumeClaim {
  // Standard object's metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // Spec defines the desired characteristics of a volume requested by a pod author.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  // +optional
  optional PersistentVolumeClaimSpec spec = 2;

  // Status represents the current information/status of a persistent volume claim.
  // Read-only.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  // +optional
  optional PersistentVolumeClaimStatus status = 3;
}

message PersistentVolumeClaimCondition {
  optional string type = 1;

  optional string status = 2;

  // Last time we probed the condition.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;

  // Last time the condition transitioned from one status to another.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;

  // Unique, this should be a short, machine understandable string that gives the reason
  // for condition's last transition. If it reports "ResizeStarted" that means the underlying
  // persistent volume is being resized.
  // +optional
  optional string reason = 5;

  // Human-readable message indicating details about last transition.
  // +optional
  optional string message = 6;
}

message PersistentVolumeClaimSpec {
  // AccessModes contains the desired access modes the volume should have.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
  // +optional
  repeated string accessModes = 1;

  // A label query over volumes to consider for binding.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;

  // Resources represents the minimum resources the volume should have.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
  // +optional
  optional ResourceRequirements resources = 2;

  // VolumeName is the binding reference to the PersistentVolume backing this claim.
  // +optional
  optional string volumeName = 3;

  // Name of the StorageClass required by the claim.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
  // +optional
  optional string storageClassName = 5;

  // volumeMode defines what type of volume is required by the claim.
  // Value of Filesystem is implied when not included in claim spec.
  // This is a beta feature.
  // +optional
  optional string volumeMode = 6;

  // This field requires the VolumeSnapshotDataSource alpha feature gate to be
  // enabled and currently VolumeSnapshot is the only supported data source.
  // If the provisioner can support VolumeSnapshot data source, it will create
  // a new volume and data will be restored to the volume at the same time.
  // If the provisioner does not support VolumeSnapshot data source, volume will
  // not be created and the failure will be reported as an event.
  // In the future, we plan to support more data source types and the behavior
  // of the provisioner may change.
  // +optional
  optional TypedLocalObjectReference dataSource = 7;
}

message PersistentVolumeClaimStatus {
  // Phase represents the current phase of PersistentVolumeClaim.
  // +optional
  optional string phase = 1;

  // AccessModes contains the actual access modes the volume backing the PVC has.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
  // +optional
  repeated string accessModes = 2;

  // Represents the actual resources of the underlying volume.
  // +optional
  map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 3;

  // Current Condition of persistent volume claim. If underlying persistent volume is being
  // resized then the Condition will be set to 'ResizeStarted'.
  // +optional
  // +patchMergeKey=type
  // +patchStrategy=merge
  repeated PersistentVolumeClaimCondition conditions = 4;
}

message PersistentVolumeClaimVolumeSource {
  // ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  optional string claimName = 1;

  // Will force the ReadOnly setting in VolumeMounts.
  // Default false.
  // +optional
  optional bool readOnly = 2;
}

message PhotonPersistentDiskVolumeSource {
  // ID that identifies Photon Controller persistent disk
  optional string pdID = 1;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  optional string fsType = 2;
}

message PodAffinity {
  // If the affinity requirements specified by this field are not met at
  // scheduling time, the pod will not be scheduled onto the node.
  // If the affinity requirements specified by this field cease to be met
  // at some point during pod execution (e.g. due to a pod label update), the
  // system may or may not try to eventually evict the pod from its node.
  // When there are multiple elements, the lists of nodes corresponding to each
  // podAffinityTerm are intersected, i.e. all terms must be satisfied.
  // +optional
  repeated PodAffinityTerm requiredDuringSchedulingIgnoredDuringExecution = 1;

  // The scheduler will prefer to schedule pods to nodes that satisfy
  // the affinity expressions specified by this field, but it may choose
  // a node that violates one or more of the expressions. The node that is
  // most preferred is the one with the greatest sum of weights, i.e.
  // for each node that meets all of the scheduling requirements (resource
  // request, requiredDuringScheduling affinity expressions, etc.),
  // compute a sum by iterating through the elements of this field and adding
  // "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
  // node(s) with the highest sum are the most preferred.
  // +optional
  repeated WeightedPodAffinityTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
}

message PodAffinityTerm {
  // A label query over a set of resources, in this case pods.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 1;

  // namespaces specifies which namespaces the labelSelector applies to (matches against);
  // null or empty list means "this pod's namespace"
  // +optional
  repeated string namespaces = 2;

  // This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
  // the labelSelector in the specified namespaces, where co-located is defined as running on a node
  // whose value of the label with key topologyKey matches that of any node on which any of the
  // selected pods is running.
  // Empty topologyKey is not allowed.
  optional string topologyKey = 3;
}

message PodAntiAffinity {
  // If the anti-affinity requirements specified by this field are not met at
  // scheduling time, the pod will not be scheduled onto the node.
  // If the anti-affinity requirements specified by this field cease to be met
  // at some point during pod execution (e.g. due to a pod label update), the
  // system may or may not try to eventually evict the pod from its node.
  // When there are multiple elements, the lists of nodes corresponding to each
  // podAffinityTerm are intersected, i.e. all terms must be satisfied.
  // +optional
  repeated PodAffinityTerm requiredDuringSchedulingIgnoredDuringExecution = 1;

  // The scheduler will prefer to schedule pods to nodes that satisfy
  // the anti-affinity expressions specified by this field, but it may choose
  // a node that violates one or more of the expressions. The node that is
  // most preferred is the one with the greatest sum of weights, i.e.
  // for each node that meets all of the scheduling requirements (resource
  // request, requiredDuringScheduling anti-affinity expressions, etc.),
  // compute a sum by iterating through the elements of this field and adding
  // "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
  // node(s) with the highest sum are the most preferred.
  // +optional
  repeated WeightedPodAffinityTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
}

message PodDNSConfig {
  // A list of DNS name server IP addresses.
  // This will be appended to the base nameservers generated from DNSPolicy.
  // Duplicated nameservers will be removed.
  // +optional
  repeated string nameservers = 1;

  // A list of DNS search domains for host-name lookup.
  // This will be appended to the base search paths generated from DNSPolicy.
  // Duplicated search paths will be removed.
  // +optional
  repeated string searches = 2;

  // A list of DNS resolver options.
  // This will be merged with the base options generated from DNSPolicy.
  // Duplicated entries will be removed. Resolution options given in Options
  // will override those that appear in the base DNSPolicy.
  // +optional
  repeated PodDNSConfigOption options = 3;
}

message PodDNSConfigOption {
  // Required.
  optional string name = 1;

  // +optional
  optional string value = 2;
}

message PodSecurityContext {
  // The SELinux context to be applied to all containers.
  // If unspecified, the container runtime will allocate a random SELinux context for each
  // container.  May also be set in SecurityContext.  If set in
  // both SecurityContext and PodSecurityContext, the value specified in SecurityContext
  // takes precedence for that container.
  // +optional
  optional SELinuxOptions seLinuxOptions = 1;

  // The Windows specific settings applied to all containers.
  // If unspecified, the options within a container's SecurityContext will be used.
  // If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
  // +optional
  optional WindowsSecurityContextOptions windowsOptions = 8;

  // The UID to run the entrypoint of the container process.
  // Defaults to user specified in image metadata if unspecified.
  // May also be set in SecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence
  // for that container.
  // +optional
  optional int64 runAsUser = 2;

  // The GID to run the entrypoint of the container process.
  // Uses runtime default if unset.
  // May also be set in SecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence
  // for that container.
  // +optional
  optional int64 runAsGroup = 6;

  // Indicates that the container must run as a non-root user.
  // If true, the Kubelet will validate the image at runtime to ensure that it
  // does not run as UID 0 (root) and fail to start the container if it does.
  // If unset or false, no such validation will be performed.
  // May also be set in SecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence.
  // +optional
  optional bool runAsNonRoot = 3;

  // A list of groups applied to the first process run in each container, in addition
  // to the container's primary GID.  If unspecified, no groups will be added to
  // any container.
  // +optional
  repeated int64 supplementalGroups = 4;

  // A special supplemental group that applies to all containers in a pod.
  // Some volume types allow the Kubelet to change the ownership of that volume
  // to be owned by the pod:
  //
  // 1. The owning GID will be the FSGroup
  // 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
  // 3. The permission bits are OR'd with rw-rw----
  //
  // If unset, the Kubelet will not modify the ownership and permissions of any volume.
  // +optional
  optional int64 fsGroup = 5;

  // Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
  // sysctls (by the container runtime) might fail to launch.
  // +optional
  repeated Sysctl sysctls = 7;
}

message PortworxVolumeSource {
  // VolumeID uniquely identifies a Portworx volume
  optional string volumeID = 1;

  // FSType represents the filesystem type to mount
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
  optional string fsType = 2;

  // Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // +optional
  optional bool readOnly = 3;
}

message PreferredSchedulingTerm {
  // Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
  optional int32 weight = 1;

  // A node selector term, associated with the corresponding weight.
  optional NodeSelectorTerm preference = 2;
}

message Probe {
  // The action taken to determine the health of a container
  optional Handler handler = 1;

  // Number of seconds after the container has started before liveness probes are initiated.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  // +optional
  optional int32 initialDelaySeconds = 2;

  // Number of seconds after which the probe times out.
  // Defaults to 1 second. Minimum value is 1.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  // +optional
  optional int32 timeoutSeconds = 3;

  // How often (in seconds) to perform the probe.
  // Default to 10 seconds. Minimum value is 1.
  // +optional
  optional int32 periodSeconds = 4;

  // Minimum consecutive successes for the probe to be considered successful after having failed.
  // Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
  // +optional
  optional int32 successThreshold = 5;

  // Minimum consecutive failures for the probe to be considered failed after having succeeded.
  // Defaults to 3. Minimum value is 1.
  // +optional
  optional int32 failureThreshold = 6;
}

message ProjectedVolumeSource {
  // list of volume projections
  repeated VolumeProjection sources = 1;

  // Mode bits to use on created files by default. Must be a value between
  // 0 and 0777.
  // Directories within the path are not affected by this setting.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  optional int32 defaultMode = 2;
}

message QuobyteVolumeSource {
  // Registry represents a single or multiple Quobyte Registry services
  // specified as a string as host:port pair (multiple entries are separated with commas)
  // which acts as the central registry for volumes
  optional string registry = 1;

  // Volume is a string that references an already created Quobyte volume by name.
  optional string volume = 2;

  // ReadOnly here will force the Quobyte volume to be mounted with read-only permissions.
  // Defaults to false.
  // +optional
  optional bool readOnly = 3;

  // User to map volume access to
  // Defaults to serivceaccount user
  // +optional
  optional string user = 4;

  // Group to map volume access to
  // Default is no group
  // +optional
  optional string group = 5;

  // Tenant owning the given Quobyte volume in the Backend
  // Used with dynamically provisioned Quobyte volumes, value is set by the plugin
  // +optional
  optional string tenant = 6;
}

message RBDVolumeSource {
  // A collection of Ceph monitors.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  repeated string monitors = 1;

  // The rados image name.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  optional string image = 2;

  // Filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  // +optional
  optional string fsType = 3;

  // The rados pool name.
  // Default is rbd.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  // +optional
  optional string pool = 4;

  // The rados user name.
  // Default is admin.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  // +optional
  optional string user = 5;

  // Keyring is the path to key ring for RBDUser.
  // Default is /etc/ceph/keyring.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  // +optional
  optional string keyring = 6;

  // SecretRef is name of the authentication secret for RBDUser. If provided
  // overrides keyring.
  // Default is nil.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  // +optional
  optional LocalObjectReference secretRef = 7;

  // ReadOnly here will force the ReadOnly setting in VolumeMounts.
  // Defaults to false.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  // +optional
  optional bool readOnly = 8;
}

message ResourceFieldSelector {
  // Container name: required for volumes, optional for env vars
  // +optional
  optional string containerName = 1;

  // Required: resource to select
  optional string resource = 2;

  // Specifies the output format of the exposed resources, defaults to "1"
  // +optional
  optional k8s.io.apimachinery.pkg.api.resource.Quantity divisor = 3;
}

message ResourceRequirements {
  // Limits describes the maximum amount of compute resources allowed.
  // More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
  // +optional
  map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> limits = 1;

  // Requests describes the minimum amount of compute resources required.
  // If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
  // otherwise to an implementation-defined value.
  // More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
  // +optional
  map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> requests = 2;
}

message SELinuxOptions {
  // User is a SELinux user label that applies to the container.
  // +optional
  optional string user = 1;

  // Role is a SELinux role label that applies to the container.
  // +optional
  optional string role = 2;

  // Type is a SELinux type label that applies to the container.
  // +optional
  optional string type = 3;

  // Level is SELinux level label that applies to the container.
  // +optional
  optional string level = 4;
}

message ScaleIOVolumeSource {
  // The host address of the ScaleIO API Gateway.
  optional string gateway = 1;

  // The name of the storage system as configured in ScaleIO.
  optional string system = 2;

  // SecretRef references to the secret for ScaleIO user and other
  // sensitive information. If this is not provided, Login operation will fail.
  optional LocalObjectReference secretRef = 3;

  // Flag to enable/disable SSL communication with Gateway, default false
  // +optional
  optional bool sslEnabled = 4;

  // The name of the ScaleIO Protection Domain for the configured storage.
  // +optional
  optional string protectionDomain = 5;

  // The ScaleIO Storage Pool associated with the protection domain.
  // +optional
  optional string storagePool = 6;

  // Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
  // Default is ThinProvisioned.
  // +optional
  optional string storageMode = 7;

  // The name of a volume already created in the ScaleIO system
  // that is associated with this volume source.
  optional string volumeName = 8;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs".
  // Default is "xfs".
  // +optional
  optional string fsType = 9;

  // Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // +optional
  optional bool readOnly = 10;
}

message SecretEnvSource {
  // The Secret to select from.
  optional LocalObjectReference localObjectReference = 1;

  // Specify whether the Secret must be defined
  // +optional
  optional bool optional = 2;
}

message SecretKeySelector {
  // The name of the secret in the pod's namespace to select from.
  optional LocalObjectReference localObjectReference = 1;

  // The key of the secret to select from.  Must be a valid secret key.
  optional string key = 2;

  // Specify whether the Secret or its key must be defined
  // +optional
  optional bool optional = 3;
}

message SecretProjection {
  optional LocalObjectReference localObjectReference = 1;

  // If unspecified, each key-value pair in the Data field of the referenced
  // Secret will be projected into the volume as a file whose name is the
  // key and content is the value. If specified, the listed keys will be
  // projected into the specified paths, and unlisted keys will not be
  // present. If a key is specified which is not present in the Secret,
  // the volume setup will error unless it is marked optional. Paths must be
  // relative and may not contain the '..' path or start with '..'.
  // +optional
  repeated KeyToPath items = 2;

  // Specify whether the Secret or its key must be defined
  // +optional
  optional bool optional = 4;
}

message SecretVolumeSource {
  // Name of the secret in the pod's namespace to use.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
  // +optional
  optional string secretName = 1;

  // If unspecified, each key-value pair in the Data field of the referenced
  // Secret will be projected into the volume as a file whose name is the
  // key and content is the value. If specified, the listed keys will be
  // projected into the specified paths, and unlisted keys will not be
  // present. If a key is specified which is not present in the Secret,
  // the volume setup will error unless it is marked optional. Paths must be
  // relative and may not contain the '..' path or start with '..'.
  // +optional
  repeated KeyToPath items = 2;

  // Optional: mode bits to use on created files by default. Must be a
  // value between 0 and 0777. Defaults to 0644.
  // Directories within the path are not affected by this setting.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  optional int32 defaultMode = 3;

  // Specify whether the Secret or its keys must be defined
  // +optional
  optional bool optional = 4;
}

message SecurityContext {
  // The capabilities to add/drop when running containers.
  // Defaults to the default set of capabilities granted by the container runtime.
  // +optional
  optional Capabilities capabilities = 1;

  // Run container in privileged mode.
  // Processes in privileged containers are essentially equivalent to root on the host.
  // Defaults to false.
  // +optional
  optional bool privileged = 2;

  // The SELinux context to be applied to the container.
  // If unspecified, the container runtime will allocate a random SELinux context for each
  // container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence.
  // +optional
  optional SELinuxOptions seLinuxOptions = 3;

  // The Windows specific settings applied to all containers.
  // If unspecified, the options from the PodSecurityContext will be used.
  // If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
  // +optional
  optional WindowsSecurityContextOptions windowsOptions = 10;

  // The UID to run the entrypoint of the container process.
  // Defaults to user specified in image metadata if unspecified.
  // May also be set in PodSecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence.
  // +optional
  optional int64 runAsUser = 4;

  // The GID to run the entrypoint of the container process.
  // Uses runtime default if unset.
  // May also be set in PodSecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence.
  // +optional
  optional int64 runAsGroup = 8;

  // Indicates that the container must run as a non-root user.
  // If true, the Kubelet will validate the image at runtime to ensure that it
  // does not run as UID 0 (root) and fail to start the container if it does.
  // If unset or false, no such validation will be performed.
  // May also be set in PodSecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence.
  // +optional
  optional bool runAsNonRoot = 5;

  // Whether this container has a read-only root filesystem.
  // Default is false.
  // +optional
  optional bool readOnlyRootFilesystem = 6;

  // AllowPrivilegeEscalation controls whether a process can gain more
  // privileges than its parent process. This bool directly controls if
  // the no_new_privs flag will be set on the container process.
  // AllowPrivilegeEscalation is true always when the container is:
  // 1) run as Privileged
  // 2) has CAP_SYS_ADMIN
  // +optional
  optional bool allowPrivilegeEscalation = 7;

  // procMount denotes the type of proc mount to use for the containers.
  // The default is DefaultProcMount which uses the container runtime defaults for
  // readonly paths and masked paths.
  // This requires the ProcMountType feature flag to be enabled.
  // +optional
  optional string procMount = 9;
}

message ServiceAccountTokenProjection {
  // Audience is the intended audience of the token. A recipient of a token
  // must identify itself with an identifier specified in the audience of the
  // token, and otherwise should reject the token. The audience defaults to the
  // identifier of the apiserver.
  // +optional
  optional string audience = 1;

  // ExpirationSeconds is the requested duration of validity of the service
  // account token. As the token approaches expiration, the kubelet volume
  // plugin will proactively rotate the service account token. The kubelet will
  // start trying to rotate the token if the token is older than 80 percent of
  // its time to live or if the token is older than 24 hours.Defaults to 1 hour
  // and must be at least 10 minutes.
  // +optional
  optional int64 expirationSeconds = 2;

  // Path is the path relative to the mount point of the file to project the
  // token into.
  optional string path = 3;
}

message StorageOSVolumeSource {
  // VolumeName is the human-readable name of the StorageOS volume.  Volume
  // names are only unique within a namespace.
  optional string volumeName = 1;

  // VolumeNamespace specifies the scope of the volume within StorageOS.  If no
  // namespace is specified then the Pod's namespace will be used.  This allows the
  // Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
  // Set VolumeName to any name to override the default behaviour.
  // Set to "default" if you are not using namespaces within StorageOS.
  // Namespaces that do not pre-exist within StorageOS will be created.
  // +optional
  optional string volumeNamespace = 2;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // +optional
  optional string fsType = 3;

  // Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // +optional
  optional bool readOnly = 4;

  // SecretRef specifies the secret to use for obtaining the StorageOS API
  // credentials.  If not specified, default values will be attempted.
  // +optional
  optional LocalObjectReference secretRef = 5;
}

message Sysctl {
  // Name of a property to set
  optional string name = 1;

  // Value of a property to set
  optional string value = 2;
}

message TCPSocketAction {
  // Number or name of the port to access on the container.
  // Number must be in the range 1 to 65535.
  // Name must be an IANA_SVC_NAME.
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 1;

  // Optional: Host name to connect to, defaults to the pod IP.
  // +optional
  optional string host = 2;
}

message Toleration {
  // Key is the taint key that the toleration applies to. Empty means match all taint keys.
  // If the key is empty, operator must be Exists; this combination means to match all values and all keys.
  // +optional
  optional string key = 1;

  // Operator represents a key's relationship to the value.
  // Valid operators are Exists and Equal. Defaults to Equal.
  // Exists is equivalent to wildcard for value, so that a pod can
  // tolerate all taints of a particular category.
  // +optional
  optional string operator = 2;

  // Value is the taint value the toleration matches to.
  // If the operator is Exists, the value should be empty, otherwise just a regular string.
  // +optional
  optional string value = 3;

  // Effect indicates the taint effect to match. Empty means match all taint effects.
  // When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
  // +optional
  optional string effect = 4;

  // TolerationSeconds represents the period of time the toleration (which must be
  // of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
  // it is not set, which means tolerate the taint forever (do not evict). Zero and
  // negative values will be treated as 0 (evict immediately) by the system.
  // +optional
  optional int64 tolerationSeconds = 5;
}

message TypedLocalObjectReference {
  // APIGroup is the group for the resource being referenced.
  // If APIGroup is not specified, the specified Kind must be in the core API group.
  // For any other third-party types, APIGroup is required.
  // +optional
  optional string apiGroup = 1;

  // Kind is the type of resource being referenced
  optional string kind = 2;

  // Name is the name of resource being referenced
  optional string name = 3;
}

message Volume {
  // Volume's name.
  // Must be a DNS_LABEL and unique within the pod.
  // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  optional string name = 1;

  // VolumeSource represents the location and type of the mounted volume.
  // If not specified, the Volume is implied to be an EmptyDir.
  // This implied behavior is deprecated and will be removed in a future version.
  optional VolumeSource volumeSource = 2;
}

message VolumeDevice {
  // name must match the name of a persistentVolumeClaim in the pod
  optional string name = 1;

  // devicePath is the path inside of the container that the device will be mapped to.
  optional string devicePath = 2;
}

message VolumeMount {
  // This must match the Name of a Volume.
  optional string name = 1;

  // Mounted read-only if true, read-write otherwise (false or unspecified).
  // Defaults to false.
  // +optional
  optional bool readOnly = 2;

  // Path within the container at which the volume should be mounted.  Must
  // not contain ':'.
  optional string mountPath = 3;

  // Path within the volume from which the container's volume should be mounted.
  // Defaults to "" (volume's root).
  // +optional
  optional string subPath = 4;

  // mountPropagation determines how mounts are propagated from the host
  // to container and the other way around.
  // When not set, MountPropagationNone is used.
  // This field is beta in 1.10.
  // +optional
  optional string mountPropagation = 5;

  // Expanded path within the volume from which the container's volume should be mounted.
  // Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
  // Defaults to "" (volume's root).
  // SubPathExpr and SubPath are mutually exclusive.
  // +optional
  optional string subPathExpr = 6;
}

message VolumeProjection {
  // information about the secret data to project
  // +optional
  optional SecretProjection secret = 1;

  // information about the downwardAPI data to project
  // +optional
  optional DownwardAPIProjection downwardAPI = 2;

  // information about the configMap data to project
  // +optional
  optional ConfigMapProjection configMap = 3;

  // information about the serviceAccountToken data to project
  // +optional
  optional ServiceAccountTokenProjection serviceAccountToken = 4;
}

message VolumeSource {
  // HostPath represents a pre-existing file or directory on the host
  // machine that is directly exposed to the container. This is generally
  // used for system agents or other privileged things that are allowed
  // to see the host machine. Most containers will NOT need this.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
  // ---
  // TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
  // mount host directories as read/write.
  // +optional
  optional HostPathVolumeSource hostPath = 1;

  // EmptyDir represents a temporary directory that shares a pod's lifetime.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
  // +optional
  optional EmptyDirVolumeSource emptyDir = 2;

  // GCEPersistentDisk represents a GCE Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  // +optional
  optional GCEPersistentDiskVolumeSource gcePersistentDisk = 3;

  // AWSElasticBlockStore represents an AWS Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  // +optional
  optional AWSElasticBlockStoreVolumeSource awsElasticBlockStore = 4;

  // GitRepo represents a git repository at a particular revision.
  // DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
  // EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
  // into the Pod's container.
  // +optional
  optional GitRepoVolumeSource gitRepo = 5;

  // Secret represents a secret that should populate this volume.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
  // +optional
  optional SecretVolumeSource secret = 6;

  // NFS represents an NFS mount on the host that shares a pod's lifetime
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  // +optional
  optional NFSVolumeSource nfs = 7;

  // ISCSI represents an ISCSI Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod.
  // More info: https://examples.k8s.io/volumes/iscsi/README.md
  // +optional
  optional ISCSIVolumeSource iscsi = 8;

  // Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
  // More info: https://examples.k8s.io/volumes/glusterfs/README.md
  // +optional
  optional GlusterfsVolumeSource glusterfs = 9;

  // PersistentVolumeClaimVolumeSource represents a reference to a
  // PersistentVolumeClaim in the same namespace.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  // +optional
  optional PersistentVolumeClaimVolumeSource persistentVolumeClaim = 10;

  // RBD represents a Rados Block Device mount on the host that shares a pod's lifetime.
  // More info: https://examples.k8s.io/volumes/rbd/README.md
  // +optional
  optional RBDVolumeSource rbd = 11;

  // FlexVolume represents a generic volume resource that is
  // provisioned/attached using an exec based plugin.
  // +optional
  optional FlexVolumeSource flexVolume = 12;

  // Cinder represents a cinder volume attached and mounted on kubelets host machine.
  // More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  // +optional
  optional CinderVolumeSource cinder = 13;

  // CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
  // +optional
  optional CephFSVolumeSource cephfs = 14;

  // Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
  // +optional
  optional FlockerVolumeSource flocker = 15;

  // DownwardAPI represents downward API about the pod that should populate this volume
  // +optional
  optional DownwardAPIVolumeSource downwardAPI = 16;

  // FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
  // +optional
  optional FCVolumeSource fc = 17;

  // AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
  // +optional
  optional AzureFileVolumeSource azureFile = 18;

  // ConfigMap represents a configMap that should populate this volume
  // +optional
  optional ConfigMapVolumeSource configMap = 19;

  // VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
  // +optional
  optional VsphereVirtualDiskVolumeSource vsphereVolume = 20;

  // Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
  // +optional
  optional QuobyteVolumeSource quobyte = 21;

  // AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
  // +optional
  optional AzureDiskVolumeSource azureDisk = 22;

  // PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
  optional PhotonPersistentDiskVolumeSource photonPersistentDisk = 23;

  // Items for all in one resources secrets, configmaps, and downward API
  optional ProjectedVolumeSource projected = 26;

  // PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
  // +optional
  optional PortworxVolumeSource portworxVolume = 24;

  // ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
  // +optional
  optional ScaleIOVolumeSource scaleIO = 25;

  // StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
  // +optional
  optional StorageOSVolumeSource storageos = 27;

  // CSI (Container Storage Interface) represents storage that is handled by an external CSI driver (Alpha feature).
  // +optional
  optional CSIVolumeSource csi = 28;
}

message VsphereVirtualDiskVolumeSource {
  // Path that identifies vSphere volume vmdk
  optional string volumePath = 1;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // +optional
  optional string fsType = 2;

  // Storage Policy Based Management (SPBM) profile name.
  // +optional
  optional string storagePolicyName = 3;

  // Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
  // +optional
  optional string storagePolicyID = 4;
}

message WeightedPodAffinityTerm {
  // weight associated with matching the corresponding podAffinityTerm,
  // in the range 1-100.
  optional int32 weight = 1;

  // Required. A pod affinity term, associated with the corresponding weight.
  optional PodAffinityTerm podAffinityTerm = 2;
}

message WindowsSecurityContextOptions {
  // GMSACredentialSpecName is the name of the GMSA credential spec to use.
  // This field is alpha-level and is only honored by servers that enable the WindowsGMSA feature flag.
  // +optional
  optional string gmsaCredentialSpecName = 1;

  // GMSACredentialSpec is where the GMSA admission webhook
  // (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
  // GMSA credential spec named by the GMSACredentialSpecName field.
  // This field is alpha-level and is only honored by servers that enable the WindowsGMSA feature flag.
  // +optional
  optional string gmsaCredentialSpec = 2;

  // The UserName in Windows to run the entrypoint of the container process.
  // Defaults to the user specified in image metadata if unspecified.
  // May also be set in PodSecurityContext. If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence.
  // This field is beta-level and may be disabled with the WindowsRunAsUserName feature flag.
  // +optional
  optional string runAsUserName = 3;
}

message Status {
  // ObservedGeneration is the 'Generation' of the Service that
  // was last processed by the controller.
  // +optional
  optional int64 observedGeneration = 1;

  // Conditions the latest available observations of a resource's current state.
  // +optional
  // +patchMergeKey=type
  // +patchStrategy=merge
  repeated Condition conditions = 2;
}

// PodTemplate holds pod specific configuration
message Template {
  // NodeSelector is a selector which must be true for the pod to fit on a node.
  // Selector which must match a node's labels for the pod to be scheduled on that node.
  // More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  // +optional
  map<string, string> nodeSelector = 8;

  // If specified, the pod's tolerations.
  // +optional
  repeated Toleration tolerations = 9;

  // If specified, the pod's scheduling constraints
  // +optional
  optional Affinity affinity = 10;

  // SecurityContext holds pod-level security attributes and common container settings.
  // Optional: Defaults to empty.  See type description for default values of each field.
  // +optional
  optional PodSecurityContext securityContext = 11;

  // List of volumes that can be mounted by containers belonging to the pod.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes
  // +optional
  // +patchMergeKey=name
  // +patchStrategy=merge,retainKeys
  repeated Volume volumes = 1;

  // RuntimeClassName refers to a RuntimeClass object in the node.k8s.io
  // group, which should be used to run this pod. If no RuntimeClass resource
  // matches the named class, the pod will not be run. If unset or empty, the
  // "legacy" RuntimeClass will be used, which is an implicit class with an
  // empty definition that uses the default runtime handler.
  // More info: https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md
  // This is a beta feature as of Kubernetes v1.14.
  // +optional
  optional string runtimeClassName = 2;

  // AutomountServiceAccountToken indicates whether pods running as this
  // service account should have an API token automatically mounted.
  // +optional
  optional bool automountServiceAccountToken = 3;

  // Set DNS policy for the pod. Defaults to "ClusterFirst". Valid values are
  // 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig
  // will be merged with the policy selected with DNSPolicy.
  // +optional
  optional string dnsPolicy = 4;

  // Specifies the DNS parameters of a pod.
  // Parameters specified here will be merged to the generated DNS
  // configuration based on DNSPolicy.
  // +optional
  optional PodDNSConfig dnsConfig = 5;

  // EnableServiceLinks indicates whether information about services should be injected into pod's
  // environment variables, matching the syntax of Docker links.
  // Optional: Defaults to true.
  // +optional
  optional bool enableServiceLinks = 6;

  // If specified, indicates the pod's priority. "system-node-critical" and
  // "system-cluster-critical" are two special keywords which indicate the
  // highest priorities with the former being the highest priority. Any other
  // name must be defined by creating a PriorityClass object with that name.
  // If not specified, the pod priority will be default or zero if there is no
  // default.
  // +optional
  optional string priorityClassName = 7;

  // SchedulerName specifies the scheduler to be used to dispatch the Pod
  // +optional
  optional string schedulerName = 12;

  // ImagePullSecrets gives the name of the secret used by the pod to pull the image if specified
  // +optional
  repeated LocalObjectReference imagePullSecrets = 13;

  // HostNetwork specifies whether the pod may use the node network namespace
  // +optional
  optional bool hostNetwork = 14;
}

// ArrayOrString is a type that can hold a single string or string array.
// Used in JSON unmarshalling so that a single JSON field can accept
// either an individual string or an array of strings.
message ArrayOrString {
  optional string type = 1;

  // Represents the stored type of ArrayOrString.
  optional string stringVal = 2;

  repeated string arrayVal = 3;
}

// CannotConvertError is returned when a field cannot be converted.
message CannotConvertError {
  optional string message = 1;

  optional string field = 2;
}

// CloudEventDelivery is the target of a cloud event along with the state of
// delivery.
message CloudEventDelivery {
  // Target points to an addressable
  optional string target = 1;

  optional CloudEventDeliveryState status = 2;
}

// CloudEventDeliveryState reports the state of a cloud event to be sent.
message CloudEventDeliveryState {
  // Current status
  optional string condition = 1;

  // SentAt is the time at which the last attempt to send the event was made
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time sentAt = 2;

  // Error is the text of error (if any)
  optional string message = 3;

  // RetryCount is the number of attempts of sending the cloud event
  optional int32 retryCount = 4;
}

// ClusterTask is a Task with a cluster scope. ClusterTasks are used to
// represent Tasks that should be publicly addressable from any namespace in the
// cluster.
message ClusterTask {
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // Spec holds the desired state of the Task from the client
  // +optional
  optional TaskSpec spec = 2;
}

// ClusterTaskList contains a list of ClusterTask
message ClusterTaskList {
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated ClusterTask items = 2;
}

// ConditionCheck represents a single evaluation of a Condition step.
message ConditionCheck {
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // +optional
  optional TaskRunSpec spec = 2;

  // +optional
  optional TaskRunStatus status = 3;
}

// ConditionCheckStatus defines the observed state of ConditionCheck
message ConditionCheckStatus {
  optional Status status = 1;

  // ConditionCheckStatusFields inlines the status fields.
  optional ConditionCheckStatusFields conditionCheckStatusFields = 2;
}

// ConditionCheckStatusFields holds the fields of ConfigurationCheck's status.
// This is defined separately and inlined so that other types can readily
// consume these fields via duck typing.
message ConditionCheckStatusFields {
  // PodName is the name of the pod responsible for executing this condition check.
  optional string podName = 1;

  // StartTime is the time the check is actually started.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 2;

  // CompletionTime is the time the check pod completed.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time completionTime = 3;

  // Check describes the state of the check container.
  // +optional
  optional ContainerState check = 4;
}

message EmbeddedTask {
  // +optional
  optional PipelineTaskMetadata metadata = 1;

  // TaskSpec is a specification of a task
  optional TaskSpec taskSpec = 2;
}

// InternalTaskModifier implements TaskModifier for resources that are built-in to Tekton Pipelines.
message InternalTaskModifier {
  repeated Step stepsToPrepend = 1;

  repeated Step stepsToAppend = 2;

  repeated Volume volumes = 3;
}

// Param declares an ArrayOrString to use for the parameter called name.
message Param {
  optional string name = 1;

  optional ArrayOrString value = 2;
}

// ParamSpec defines arbitrary parameters needed beyond typed inputs (such as
// resources). Parameter values are provided by users as inputs on a TaskRun
// or PipelineRun.
message ParamSpec {
  // Name declares the name by which a parameter is referenced.
  optional string name = 1;

  // Type is the user-specified type of the parameter. The possible types
  // are currently "string" and "array", and "string" is the default.
  // +optional
  optional string type = 2;

  // Description is a user-facing description of the parameter that may be
  // used to populate a UI.
  // +optional
  optional string description = 3;

  // Default is the value a parameter takes if no input value is supplied. If
  // default is set, a Task may be executed without a supplied value for the
  // parameter.
  // +optional
  optional ArrayOrString default = 4;
}

// Pipeline describes a list of Tasks to execute. It expresses how outputs
// of tasks feed into inputs of subsequent tasks.
// +k8s:openapi-gen=true
message Pipeline {
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // Spec holds the desired state of the Pipeline from the client
  // +optional
  optional PipelineSpec spec = 2;
}

// PipelineDeclaredResource is used by a Pipeline to declare the types of the
// PipelineResources that it will required to run and names which can be used to
// refer to these PipelineResources in PipelineTaskResourceBindings.
message PipelineDeclaredResource {
  // Name is the name that will be used by the Pipeline to refer to this resource.
  // It does not directly correspond to the name of any PipelineResources Task
  // inputs or outputs, and it does not correspond to the actual names of the
  // PipelineResources that will be bound in the PipelineRun.
  optional string name = 1;

  // Type is the type of the PipelineResource.
  optional string type = 2;

  // Optional declares the resource as optional.
  // optional: true - the resource is considered optional
  // optional: false - the resource is considered required (default/equivalent of not specifying it)
  optional bool optional = 3;
}

// PipelineList contains a list of Pipeline
message PipelineList {
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Pipeline items = 2;
}

// PipelineRef can be used to refer to a specific instance of a Pipeline.
// Copied from CrossVersionObjectReference: https://github.com/kubernetes/kubernetes/blob/169df7434155cbbc22f1532cba8e0a9588e29ad8/pkg/apis/autoscaling/types.go#L64
message PipelineRef {
  // Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
  optional string name = 1;

  // API version of the referent
  // +optional
  optional string apiVersion = 2;

  // Bundle url reference to a Tekton Bundle.
  // +optional
  optional string bundle = 3;
}

// PipelineResourceBinding connects a reference to an instance of a PipelineResource
// with a PipelineResource dependency that the Pipeline has declared
message PipelineResourceBinding {
  // Name is the name of the PipelineResource in the Pipeline's declaration
  optional string name = 1;

  // ResourceRef is a reference to the instance of the actual PipelineResource
  // that should be used
  // +optional
  optional PipelineResourceRef resourceRef = 2;

  // ResourceSpec is specification of a resource that should be created and
  // consumed by the task
  // +optional
  optional PipelineResourceSpec resourceSpec = 3;
}

// PipelineResourceRef can be used to refer to a specific instance of a Resource
message PipelineResourceRef {
  // Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
  optional string name = 1;

  // API version of the referent
  // +optional
  optional string apiVersion = 2;
}

// PipelineResourceResult used to export the image name and digest as json
message PipelineResourceResult {
  optional string key = 1;

  optional string value = 2;

  optional string resourceName = 3;

  // The field ResourceRef should be deprecated and removed in the next API version.
  // See https://github.com/tektoncd/pipeline/issues/2694 for more information.
  optional PipelineResourceRef resourceRef = 4;

  optional string type = 5;
}

// PipelineResult used to describe the results of a pipeline
message PipelineResult {
  // Name the given name
  optional string name = 1;

  // Description is a human-readable description of the result
  // +optional
  optional string description = 2;

  // Value the expression used to retrieve the value
  optional string value = 3;
}

// PipelineRun represents a single execution of a Pipeline. PipelineRuns are how
// the graph of Tasks declared in a Pipeline are executed; they specify inputs
// to Pipelines such as parameter values and capture operational aspects of the
// Tasks execution such as service account and tolerations. Creating a
// PipelineRun creates TaskRuns for Tasks in the referenced Pipeline.
//
// +k8s:openapi-gen=true
message PipelineRun {
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // +optional
  optional PipelineRunSpec spec = 2;

  // +optional
  optional PipelineRunStatus status = 3;
}

// PipelineRunConditionCheckStatus returns the condition check status
message PipelineRunConditionCheckStatus {
  // ConditionName is the name of the Condition
  optional string conditionName = 1;

  // Status is the ConditionCheckStatus for the corresponding ConditionCheck
  // +optional
  optional ConditionCheckStatus status = 2;
}

// PipelineRunList contains a list of PipelineRun
message PipelineRunList {
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated PipelineRun items = 2;
}

// PipelineRunResult used to describe the results of a pipeline
message PipelineRunResult {
  // Name is the result's name as declared by the Pipeline
  optional string name = 1;

  // Value is the result returned from the execution of this PipelineRun
  optional string value = 2;
}

// PipelineRunSpec defines the desired state of PipelineRun
message PipelineRunSpec {
  // +optional
  optional PipelineRef pipelineRef = 1;

  // +optional
  optional PipelineSpec pipelineSpec = 2;

  // Resources is a list of bindings specifying which actual instances of
  // PipelineResources to use for the resources the Pipeline has declared
  // it needs.
  repeated PipelineResourceBinding resources = 3;

  // Params is a list of parameter names and values.
  repeated Param params = 4;

  // +optional
  optional string serviceAccountName = 5;

  // Deprecated: use taskRunSpecs.ServiceAccountName instead
  // +optional
  repeated PipelineRunSpecServiceAccountName serviceAccountNames = 6;

  // Used for cancelling a pipelinerun (and maybe more later on)
  // +optional
  optional string status = 7;

  // Time after which the Pipeline times out. Defaults to never.
  // Refer to Go's ParseDuration documentation for expected format: https://golang.org/pkg/time/#ParseDuration
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration timeout = 8;

  // PodTemplate holds pod specific configuration
  optional Template podTemplate = 9;

  // Workspaces holds a set of workspace bindings that must match names
  // with those declared in the pipeline.
  // +optional
  repeated WorkspaceBinding workspaces = 10;

  // TaskRunSpecs holds a set of runtime specs
  // +optional
  repeated PipelineTaskRunSpec taskRunSpecs = 11;
}

// PipelineRunSpecServiceAccountName can be used to configure specific
// ServiceAccountName for a concrete Task
message PipelineRunSpecServiceAccountName {
  optional string taskName = 1;

  optional string serviceAccountName = 2;
}

// PipelineRunStatus defines the observed state of PipelineRun
message PipelineRunStatus {
  optional Status status = 1;

  // PipelineRunStatusFields inlines the status fields.
  optional PipelineRunStatusFields pipelineRunStatusFields = 2;
}

// PipelineRunStatusFields holds the fields of PipelineRunStatus' status.
// This is defined separately and inlined so that other types can readily
// consume these fields via duck typing.
message PipelineRunStatusFields {
  // StartTime is the time the PipelineRun is actually started.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 1;

  // CompletionTime is the time the PipelineRun completed.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time completionTime = 2;

  // map of PipelineRunTaskRunStatus with the taskRun name as the key
  // +optional
  map<string, PipelineRunTaskRunStatus> taskRuns = 3;

  // PipelineResults are the list of results written out by the pipeline task's containers
  // +optional
  repeated PipelineRunResult pipelineResults = 4;

  // PipelineRunSpec contains the exact spec used to instantiate the run
  optional PipelineSpec pipelineSpec = 5;

  // list of tasks that were skipped due to when expressions evaluating to false
  // +optional
  repeated SkippedTask skippedTasks = 6;
}

// PipelineRunTaskRunStatus contains the name of the PipelineTask for this TaskRun and the TaskRun's Status
message PipelineRunTaskRunStatus {
  // PipelineTaskName is the name of the PipelineTask.
  optional string pipelineTaskName = 1;

  // Status is the TaskRunStatus for the corresponding TaskRun
  // +optional
  optional TaskRunStatus status = 2;

  // ConditionChecks maps the name of a condition check to its Status
  // +optional
  map<string, PipelineRunConditionCheckStatus> conditionChecks = 3;

  // WhenExpressions is the list of checks guarding the execution of the PipelineTask
  // +optional
  repeated WhenExpression whenExpressions = 4;
}

// PipelineSpec defines the desired state of Pipeline.
message PipelineSpec {
  // Description is a user-facing description of the pipeline that may be
  // used to populate a UI.
  // +optional
  optional string description = 1;

  // Resources declares the names and types of the resources given to the
  // Pipeline's tasks as inputs and outputs.
  repeated PipelineDeclaredResource resources = 2;

  // Tasks declares the graph of Tasks that execute when this Pipeline is run.
  repeated PipelineTask tasks = 3;

  // Params declares a list of input parameters that must be supplied when
  // this Pipeline is run.
  repeated ParamSpec params = 4;

  // Workspaces declares a set of named workspaces that are expected to be
  // provided by a PipelineRun.
  // +optional
  repeated PipelineWorkspaceDeclaration workspaces = 5;

  // Results are values that this pipeline can output once run
  // +optional
  repeated PipelineResult results = 6;

  // Finally declares the list of Tasks that execute just before leaving the Pipeline
  // i.e. either after all Tasks are finished executing successfully
  // or after a failure which would result in ending the Pipeline
  repeated PipelineTask finally = 7;
}

// PipelineTask defines a task in a Pipeline, passing inputs from both
// Params and from the output of previous tasks.
message PipelineTask {
  // Name is the name of this task within the context of a Pipeline. Name is
  // used as a coordinate with the `from` and `runAfter` fields to establish
  // the execution order of tasks relative to one another.
  optional string name = 1;

  // TaskRef is a reference to a task definition.
  // +optional
  optional TaskRef taskRef = 2;

  // TaskSpec is a specification of a task
  // +optional
  optional EmbeddedTask taskSpec = 3;

  // Conditions is a list of conditions that need to be true for the task to run
  // Conditions are deprecated, use WhenExpressions instead
  // +optional
  repeated PipelineTaskCondition conditions = 4;

  // WhenExpressions is a list of when expressions that need to be true for the task to run
  // +optional
  repeated WhenExpression when = 5;

  // Retries represents how many times this task should be retried in case of task failure: ConditionSucceeded set to False
  // +optional
  optional int64 retries = 6;

  // RunAfter is the list of PipelineTask names that should be executed before
  // this Task executes. (Used to force a specific ordering in graph execution.)
  // +optional
  repeated string runAfter = 7;

  // Resources declares the resources given to this task as inputs and
  // outputs.
  // +optional
  optional PipelineTaskResources resources = 8;

  // Parameters declares parameters passed to this task.
  // +optional
  repeated Param params = 9;

  // Workspaces maps workspaces from the pipeline spec to the workspaces
  // declared in the Task.
  // +optional
  repeated WorkspacePipelineTaskBinding workspaces = 10;

  // Time after which the TaskRun times out. Defaults to 1 hour.
  // Specified TaskRun timeout should be less than 24h.
  // Refer Go's ParseDuration documentation for expected format: https://golang.org/pkg/time/#ParseDuration
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration timeout = 11;
}

// PipelineTaskCondition allows a PipelineTask to declare a Condition to be evaluated before
// the Task is run.
message PipelineTaskCondition {
  // ConditionRef is the name of the Condition to use for the conditionCheck
  optional string conditionRef = 1;

  // Params declare parameters passed to this Condition
  // +optional
  repeated Param params = 2;

  // Resources declare the resources provided to this Condition as input
  repeated PipelineTaskInputResource resources = 3;
}

// PipelineTaskInputResource maps the name of a declared PipelineResource input
// dependency in a Task to the resource in the Pipeline's DeclaredPipelineResources
// that should be used. This input may come from a previous task.
message PipelineTaskInputResource {
  // Name is the name of the PipelineResource as declared by the Task.
  optional string name = 1;

  // Resource is the name of the DeclaredPipelineResource to use.
  optional string resource = 2;

  // From is the list of PipelineTask names that the resource has to come from.
  // (Implies an ordering in the execution graph.)
  // +optional
  repeated string from = 3;
}

message PipelineTaskMetadata {
  // +optional
  map<string, string> labels = 1;

  // +optional
  map<string, string> annotations = 2;
}

// PipelineTaskOutputResource maps the name of a declared PipelineResource output
// dependency in a Task to the resource in the Pipeline's DeclaredPipelineResources
// that should be used.
message PipelineTaskOutputResource {
  // Name is the name of the PipelineResource as declared by the Task.
  optional string name = 1;

  // Resource is the name of the DeclaredPipelineResource to use.
  optional string resource = 2;
}

// PipelineTaskParam is used to provide arbitrary string parameters to a Task.
message PipelineTaskParam {
  optional string name = 1;

  optional string value = 2;
}

// PipelineTaskResources allows a Pipeline to declare how its DeclaredPipelineResources
// should be provided to a Task as its inputs and outputs.
message PipelineTaskResources {
  // Inputs holds the mapping from the PipelineResources declared in
  // DeclaredPipelineResources to the input PipelineResources required by the Task.
  repeated PipelineTaskInputResource inputs = 1;

  // Outputs holds the mapping from the PipelineResources declared in
  // DeclaredPipelineResources to the input PipelineResources required by the Task.
  repeated PipelineTaskOutputResource outputs = 2;
}

// PipelineTaskRun reports the results of running a step in the Task. Each
// task has the potential to succeed or fail (based on the exit code)
// and produces logs.
message PipelineTaskRun {
  optional string name = 1;
}

// PipelineTaskRunSpec  can be used to configure specific
// specs for a concrete Task
message PipelineTaskRunSpec {
  optional string pipelineTaskName = 1;

  optional string taskServiceAccountName = 2;

  optional Template taskPodTemplate = 3;
}

// WorkspacePipelineDeclaration creates a named slot in a Pipeline that a PipelineRun
// is expected to populate with a workspace binding.
// Deprecated: use PipelineWorkspaceDeclaration type instead
message PipelineWorkspaceDeclaration {
  // Name is the name of a workspace to be provided by a PipelineRun.
  optional string name = 1;

  // Description is a human readable string describing how the workspace will be
  // used in the Pipeline. It can be useful to include a bit of detail about which
  // tasks are intended to have access to the data on the workspace.
  // +optional
  optional string description = 2;

  // Optional marks a Workspace as not being required in PipelineRuns. By default
  // this field is false and so declared workspaces are required.
  optional bool optional = 3;
}

// ResultRef is a type that represents a reference to a task run result
message ResultRef {
  optional string pipelineTask = 1;

  optional string result = 2;
}

// Sidecar has nearly the same data structure as Step, consisting of a Container and an optional Script, but does not have the ability to timeout.
message Sidecar {
  optional Container container = 1;

  // Script is the contents of an executable file to execute.
  //
  // If Script is not empty, the Step cannot have an Command or Args.
  optional string script = 2;
}

// SidecarState reports the results of running a sidecar in a Task.
message SidecarState {
  optional ContainerState containerState = 1;

  optional string name = 2;

  optional string container = 3;

  optional string imageID = 4;
}

// SkippedTask is used to describe the Tasks that were skipped due to their When Expressions
// evaluating to False. This is a struct because we are looking into including more details
// about the When Expressions that caused this Task to be skipped.
message SkippedTask {
  // Name is the Pipeline Task name
  optional string name = 1;

  // WhenExpressions is the list of checks guarding the execution of the PipelineTask
  // +optional
  repeated WhenExpression whenExpressions = 2;
}

// Step embeds the Container type, which allows it to include fields not
// provided by Container.
message Step {
  optional Container container = 1;

  // Script is the contents of an executable file to execute.
  //
  // If Script is not empty, the Step cannot have an Command and the Args will be passed to the Script.
  optional string script = 2;

  // Timeout is the time after which the step times out. Defaults to never.
  // Refer to Go's ParseDuration documentation for expected format: https://golang.org/pkg/time/#ParseDuration
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration timeout = 3;
}

// StepState reports the results of running a step in a Task.
message StepState {
  optional ContainerState containerState = 1;

  optional string name = 2;

  optional string container = 3;

  optional string imageID = 4;
}

// Task represents a collection of sequential steps that are run as part of a
// Pipeline using a set of inputs and producing a set of outputs. Tasks execute
// when TaskRuns are created that provide the input parameters and resources and
// output resources the Task requires.
//
// +k8s:openapi-gen=true
message Task {
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // Spec holds the desired state of the Task from the client
  // +optional
  optional TaskSpec spec = 2;
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// TaskList contains a list of Task
message TaskList {
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated Task items = 2;
}

// TaskRef can be used to refer to a specific instance of a task.
// Copied from CrossVersionObjectReference: https://github.com/kubernetes/kubernetes/blob/169df7434155cbbc22f1532cba8e0a9588e29ad8/pkg/apis/autoscaling/types.go#L64
message TaskRef {
  // Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
  optional string name = 1;

  // TaskKind indicates the kind of the task, namespaced or cluster scoped.
  optional string kind = 2;

  // API version of the referent
  // +optional
  optional string apiVersion = 3;

  // Bundle url reference to a Tekton Bundle.
  // +optional
  optional string bundle = 4;
}

// TaskResource defines an input or output Resource declared as a requirement
// by a Task. The Name field will be used to refer to these Resources within
// the Task definition, and when provided as an Input, the Name will be the
// path to the volume mounted containing this Resource as an input (e.g.
// an input Resource named `workspace` will be mounted at `/workspace`).
message TaskResource {
  optional ResourceDeclaration resourceDeclaration = 1;
}

// TaskResourceBinding points to the PipelineResource that
// will be used for the Task input or output called Name.
message TaskResourceBinding {
  optional PipelineResourceBinding pipelineResourceBinding = 1;

  // Paths will probably be removed in #1284, and then PipelineResourceBinding can be used instead.
  // The optional Path field corresponds to a path on disk at which the Resource can be found
  // (used when providing the resource via mounted volume, overriding the default logic to fetch the Resource).
  // +optional
  repeated string paths = 2;
}

// TaskResources allows a Pipeline to declare how its DeclaredPipelineResources
// should be provided to a Task as its inputs and outputs.
message TaskResources {
  // Inputs holds the mapping from the PipelineResources declared in
  // DeclaredPipelineResources to the input PipelineResources required by the Task.
  repeated TaskResource inputs = 1;

  // Outputs holds the mapping from the PipelineResources declared in
  // DeclaredPipelineResources to the input PipelineResources required by the Task.
  repeated TaskResource outputs = 2;
}

// TaskResult used to describe the results of a task
message TaskResult {
  // Name the given name
  optional string name = 1;

  // Description is a human-readable description of the result
  // +optional
  optional string description = 2;
}

// TaskRun represents a single execution of a Task. TaskRuns are how the steps
// specified in a Task are executed; they specify the parameters and resources
// used to run the steps in a Task.
//
// +k8s:openapi-gen=true
message TaskRun {
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // +optional
  optional TaskRunSpec spec = 2;

  // +optional
  optional TaskRunStatus status = 3;
}

// TaskRunInputs holds the input values that this task was invoked with.
message TaskRunInputs {
  // +optional
  repeated TaskResourceBinding resources = 1;

  // +optional
  repeated Param params = 2;
}

// TaskRunList contains a list of TaskRun
message TaskRunList {
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated TaskRun items = 2;
}

// TaskRunOutputs holds the output values that this task was invoked with.
message TaskRunOutputs {
  // +optional
  repeated TaskResourceBinding resources = 1;
}

// TaskRunResources allows a TaskRun to declare inputs and outputs TaskResourceBinding
message TaskRunResources {
  // Inputs holds the inputs resources this task was invoked with
  repeated TaskResourceBinding inputs = 1;

  // Outputs holds the inputs resources this task was invoked with
  repeated TaskResourceBinding outputs = 2;
}

// TaskRunResult used to describe the results of a task
message TaskRunResult {
  // Name the given name
  optional string name = 1;

  // Value the given value of the result
  optional string value = 2;
}

// TaskRunSpec defines the desired state of TaskRun
message TaskRunSpec {
  // +optional
  repeated Param params = 1;

  // +optional
  optional TaskRunResources resources = 2;

  // +optional
  optional string serviceAccountName = 3;

  // no more than one of the TaskRef and TaskSpec may be specified.
  // +optional
  optional TaskRef taskRef = 4;

  // +optional
  optional TaskSpec taskSpec = 5;

  // Used for cancelling a taskrun (and maybe more later on)
  // +optional
  optional string status = 6;

  // Time after which the build times out. Defaults to 1 hour.
  // Specified build timeout should be less than 24h.
  // Refer Go's ParseDuration documentation for expected format: https://golang.org/pkg/time/#ParseDuration
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration timeout = 7;

  // PodTemplate holds pod specific configuration
  optional Template podTemplate = 8;

  // Workspaces is a list of WorkspaceBindings from volumes to workspaces.
  // +optional
  repeated WorkspaceBinding workspaces = 9;
}

// TaskRunStatus defines the observed state of TaskRun
message TaskRunStatus {
  optional Status status = 1;

  // TaskRunStatusFields inlines the status fields.
  optional TaskRunStatusFields taskRunStatusFields = 2;
}

// TaskRunStatusFields holds the fields of TaskRun's status.  This is defined
// separately and inlined so that other types can readily consume these fields
// via duck typing.
message TaskRunStatusFields {
  // PodName is the name of the pod responsible for executing this task's steps.
  optional string podName = 1;

  // StartTime is the time the build is actually started.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 2;

  // CompletionTime is the time the build completed.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time completionTime = 3;

  // Steps describes the state of each build step container.
  // +optional
  repeated StepState steps = 4;

  // CloudEvents describe the state of each cloud event requested via a
  // CloudEventResource.
  // +optional
  repeated CloudEventDelivery cloudEvents = 5;

  // RetriesStatus contains the history of TaskRunStatus in case of a retry in order to keep record of failures.
  // All TaskRunStatus stored in RetriesStatus will have no date within the RetriesStatus as is redundant.
  // +optional
  repeated TaskRunStatus retriesStatus = 6;

  // Results from Resources built during the taskRun. currently includes
  // the digest of build container images
  // +optional
  repeated PipelineResourceResult resourcesResult = 7;

  // TaskRunResults are the list of results written out by the task's containers
  // +optional
  repeated TaskRunResult taskResults = 8;

  // The list has one entry per sidecar in the manifest. Each entry is
  // represents the imageid of the corresponding sidecar.
  repeated SidecarState sidecars = 9;

  // TaskSpec contains the Spec from the dereferenced Task definition used to instantiate this TaskRun.
  optional TaskSpec taskSpec = 10;
}

// TaskSpec defines the desired state of Task.
message TaskSpec {
  // Resources is a list input and output resource to run the task
  // Resources are represented in TaskRuns as bindings to instances of
  // PipelineResources.
  // +optional
  optional TaskResources resources = 1;

  // Params is a list of input parameters required to run the task. Params
  // must be supplied as inputs in TaskRuns unless they declare a default
  // value.
  // +optional
  repeated ParamSpec params = 2;

  // Description is a user-facing description of the task that may be
  // used to populate a UI.
  // +optional
  optional string description = 3;

  // Steps are the steps of the build; each step is run sequentially with the
  // source mounted into /workspace.
  repeated Step steps = 4;

  // Volumes is a collection of volumes that are available to mount into the
  // steps of the build.
  repeated Volume volumes = 5;

  // StepTemplate can be used as the basis for all step containers within the
  // Task, so that the steps inherit settings on the base container.
  optional Container stepTemplate = 6;

  // Sidecars are run alongside the Task's step containers. They begin before
  // the steps start and end after the steps complete.
  repeated Sidecar sidecars = 7;

  // Workspaces are the volumes that this Task requires.
  repeated WorkspaceDeclaration workspaces = 8;

  // Results are values that this Task can output
  repeated TaskResult results = 9;
}

// WhenExpression allows a PipelineTask to declare expressions to be evaluated before the Task is run
// to determine whether the Task should be executed or skipped
message WhenExpression {
  // Input is the string for guard checking which can be a static input or an output from a parent Task
  optional string input = 1;

  // Operator that represents an Input's relationship to the values
  optional string operator = 2;

  // Values is an array of strings, which is compared against the input, for guard checking
  // It must be non-empty
  repeated string values = 3;
}

// WorkspaceBinding maps a Task's declared workspace to a Volume.
message WorkspaceBinding {
  // Name is the name of the workspace populated by the volume.
  optional string name = 1;

  // SubPath is optionally a directory on the volume which should be used
  // for this binding (i.e. the volume will be mounted at this sub directory).
  // +optional
  optional string subPath = 2;

  // VolumeClaimTemplate is a template for a claim that will be created in the same namespace.
  // The PipelineRun controller is responsible for creating a unique claim for each instance of PipelineRun.
  // +optional
  optional PersistentVolumeClaim volumeClaimTemplate = 3;

  // PersistentVolumeClaimVolumeSource represents a reference to a
  // PersistentVolumeClaim in the same namespace. Either this OR EmptyDir can be used.
  // +optional
  optional PersistentVolumeClaimVolumeSource persistentVolumeClaim = 4;

  // EmptyDir represents a temporary directory that shares a Task's lifetime.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
  // Either this OR PersistentVolumeClaim can be used.
  // +optional
  optional EmptyDirVolumeSource emptyDir = 5;

  // ConfigMap represents a configMap that should populate this workspace.
  // +optional
  optional ConfigMapVolumeSource configMap = 6;

  // Secret represents a secret that should populate this workspace.
  // +optional
  optional SecretVolumeSource secret = 7;
}

// WorkspaceDeclaration is a declaration of a volume that a Task requires.
message WorkspaceDeclaration {
  // Name is the name by which you can bind the volume at runtime.
  optional string name = 1;

  // Description is an optional human readable description of this volume.
  // +optional
  optional string description = 2;

  // MountPath overrides the directory that the volume will be made available at.
  // +optional
  optional string mountPath = 3;

  // ReadOnly dictates whether a mounted volume is writable. By default this
  // field is false and so mounted volumes are writable.
  optional bool readOnly = 4;

  // Optional marks a Workspace as not being required in TaskRuns. By default
  // this field is false and so declared workspaces are required.
  optional bool optional = 5;
}

// WorkspacePipelineTaskBinding describes how a workspace passed into the pipeline should be
// mapped to a task's declared workspace.
message WorkspacePipelineTaskBinding {
  // Name is the name of the workspace as declared by the task
  optional string name = 1;

  // Workspace is the name of the workspace declared by the pipeline
  optional string workspace = 2;

  // SubPath is optionally a directory on the volume which should be used
  // for this binding (i.e. the volume will be mounted at this sub directory).
  // +optional
  optional string subPath = 3;
}

message PipelineResourceSpec {
  // Description is a user-facing description of the resource that may be
  // used to populate a UI.
  // +optional
  optional string description = 1;

  optional string type = 2;

  repeated ResourceParam params = 3;

  // Secrets to fetch to populate some of resource fields
  // +optional
  repeated SecretParam secrets = 4;
}

// ResourceDeclaration defines an input or output PipelineResource declared as a requirement
// by another type such as a Task or Condition. The Name field will be used to refer to these
// PipelineResources within the type's definition, and when provided as an Input, the Name will be the
// path to the volume mounted containing this PipelineResource as an input (e.g.
// an input Resource named `workspace` will be mounted at `/workspace`).
message ResourceDeclaration {
  // Name declares the name by which a resource is referenced in the
  // definition. Resources may be referenced by name in the definition of a
  // Task's steps.
  optional string name = 1;

  // Type is the type of this resource;
  optional string type = 2;

  // Description is a user-facing description of the declared resource that may be
  // used to populate a UI.
  // +optional
  optional string description = 3;

  // TargetPath is the path in workspace directory where the resource
  // will be copied.
  // +optional
  optional string targetPath = 4;

  // Optional declares the resource as optional.
  // By default optional is set to false which makes a resource required.
  // optional: true - the resource is considered optional
  // optional: false - the resource is considered required (equivalent of not specifying it)
  optional bool optional = 5;
}

// ResourceParam declares a string value to use for the parameter called Name, and is used in
// the specific context of PipelineResources.
message ResourceParam {
  optional string name = 1;

  optional string value = 2;
}

message SecretParam {
  optional string fieldName = 1;

  optional string secretKey = 2;

  optional string secretName = 3;
}

message Condition {
  // Type of condition.
  // +required
  optional string type = 1;

  // Status of the condition, one of True, False, Unknown.
  // +required
  optional string status = 2;

  // Severity with which to treat failures of this type of condition.
  // When this is not specified, it defaults to Error.
  // +optional
  optional string severity = 3;

  // LastTransitionTime is the last time the condition transitioned from one status to another.
  // We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
  // differences (all other things held constant).
  // +optional
  optional VolatileTime lastTransitionTime = 4;

  // The reason for the condition's last transition.
  // +optional
  optional string reason = 5;

  // A human readable message indicating details about the transition.
  // +optional
  optional string message = 6;
}

message VolatileTime {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time inner = 1;
}

